# Consider the fraction, n/d, where n and d are positive integers. 
# If n<d and HCF(n,d)=1, it is called a reduced proper fraction.

# If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:

# 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

# It can be seen that there are 3 fractions between 1/3 and 1/2.

# How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d ≤ 12,000?



# Between 1/3 and 1/2 = between x/3x and x/2x
# Any fraction equal to x/n, where 2x < n < 3x, will work, for all values of x 
# Also, any fraction equal to n/2x, where 2x/3 < n < x, will work, for all values of x
# Finally, any fraction equal to n/3x, where x < n < 3x/2, will work, for all values of x

# Keep in mind that these will only work if they don't reduce

# Finding everything for d <= 12,000 will give us a lot of numbers

# Is the limit of x equal to 4000? Should be. 
# Any fraction that lies between 4000/12000 and 8000/12000 either doesn't count (say, 4337/13000) because d > 12000,
# or can be reduced to x / y, where y <= 12000 and 4000 < x < 8000

# I'll start by trying the brute-force way, though I expect that totient trickery could help us out

# from math import ceil
# from sympy import gcd

# pairs = []

# for i in range(1, 4000):
# 	x = i
# 	two_x = i*2
# 	three_x = i*3
# 	for j in range(two_x + 1, three_x):
# 		if gcd(x,j) == 1:
# 			pairs.append([x, j])
# 	two_thirds_x = ceil(x*2 / 3)
# 	for k in range(two_thirds_x + 1, x):
# 		if gcd(x,two_x) == 1:
# 			pairs.append([k, two_x])	
# 	three_halves_x = ceil(x*3 / 2)
# 	for l in range(x + 1, three_halves_x):
# 		if gcd(l,three_x) == 1:
# 			pairs.append([l, three_x])

# # print(pairs)			

# print(len(pairs)) # Returns everything in about 7 seconds, but that's over 10,000,000 pairs. And now we have to reduce them.

# reduce_count = 0

# for pair in pairs:
# 	if gcd(pair[0], pair[1]) != 1:
# 		reduce_count += 1

# print(len(pairs) - reduce_count) # This takes about 13 seconds for 400 numbers, looking at roughly 100,000 pairs. Will take more than a minute.

# Adjusted code above to only append pairs if they have a GCD of 1, doesn't help


# Okay, let's try to work some totient magic.
# The brute-force totient version: Find the totients for all numbers in (2, 12000), then, for each number, add the number of totients between 1/3 and 2/3 of that number

# Trouble is, past totient problems just cared about the number of totients, not the specific list of totients for each number. 
# Ideally, we could just get a reasonable estimate by taking 1/3 of the total number of totients from 2 to 12000, but life is rarely ideal

# Thinking in another direction: We have a number, n. How can we find the number of reduced fractions between 1/3 and 2/3 when the denominator is n?
# ...okay, wait, that makes the problem very easy, right? 

# from math import ceil, floor
# from sympy import gcd

# pairs = []

# limit = 12000
# count = 0

# for i in range(5, limit + 1): # First number we actually find is 2/5
# 	for j in range(ceil(i/3), ceil(i/2)):
# 		if gcd(i, j) == 1:
# 			count += 1 
# 			pairs.append([j, i])

# # print(pairs)
# print(count) # Takes 3 seconds for 400, which is better, but still not great

# Ways to speed things up: If i is even, jump ahead by twos (should shave 1/4 of the time, still not great)

# What if we did it backwards? Find all the working denominators for each numerator? 

# from sympy import gcd

# pairs = []

# limit = 400
# count = 0

# for i in range(1, limit):
# 	for j in range(2*i + 1, 3*i):
# 		if gcd(i,j) == 1:
# 			count += 1
# 			pairs.append([i,j])

# # print(pairs)
# print(count) # Still about the same speed, which makes sense -- we're still checking all the same numbers.


# Clearly, the slow part of this process is the GCD checking. Can we find a way to skip this? And just automatically generate working pairs?
# New idea: For every pair we find, all multiples of that pair will just reduce to that pair.
# For example, once we find 3/8, all fractions 3x/8x are accounted for.
# This is one quick way to get the total fraction count

# We could built a dictionary where the keys are denominators and the values are lists of working numerators
# And then, for each key, look at all keys of the form x * key and remove values of the form x * value for each value in the original key

# Still feels like a lot of operations, though. We're looking at thousands of keys, and for each key, looping over thousands of numbers...


# After some searching, I find that the Farey series exists for situations like this.
# This lets us find a list of all reduced fractions between 0 and 1
# And each term in the sequence is generated by the previous two terms
# So if we start at 1/3, and end at 2/3...

# How it works: If a/b, c/d, and p/q are 3 consecutive terms, c/d = (a + p) / (b + q)
# This does make sense: Imagine 1/5, 1/4, 2/7 in F(8). 1/4 = (1+2) / (5+7)
# Which means that some number k must exist such that k*c = a + p and k*d = b + q
# So p = k*c - a, q = k*d - b
# We need k to be as large as possible within the limits of our denominator (the bigger k gets, the smaller the step we've taken)
# Looking at 1/5 and 1/4, we see that p = 2 = 3*1 - 1, q = 7 = 3*4 - 5
# k <= (n + b)/d, since k*d - b must be less than or equal to n (otherwise, denominator would be too big)


def farey_function(n, start_num, start_den, end_num, end_den): # Rewriting from scratch, though Wikipedia had a version
	count = 0
	limit = end_num / end_den

	num, den = start_num, start_den
	next_num = 4000 # Programmatically setting this would be a bit annoying, since we'd need to find a relative prime.
	next_den = 11999 # When I accidentally set this to 4001/12000, the answer was 1/3 of what it should've been. Math is strange.

	while next_num / next_den < limit: # If we hit a number that must be past our upper limit, stop!
		k = int((n + den) / next_den) # Make k as large as possible, see above
		future_num = (k * next_num) - num
		future_den = (k * next_den) - den
		num, den, next_num, next_den = next_num, next_den, future_num, future_den # Set up next number in sequence
		# print("%d/%d" % (num, den))
		count += 1

	print("Count:", count)

farey_function(12000, 1, 3, 1, 2)









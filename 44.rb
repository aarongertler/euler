# Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. 
# The first ten pentagonal numbers are:

# 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. 
# However, their difference, 70 − 22 = 48, is not pentagonal.

# Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference 
# are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?


# We know we have a minimum difference when A - B is smaller than the difference between A and the next pentagonal number
# Trouble is, every time we generate a pentagonal number, we have more differences to check
# I guess we can check first to see if brute force is practical:

p_array = []
count = 0

while count < 5000
  count += 1
  p_array << (count * (3 * count - 1) / 2) # Generate the first 5000 pentagonal numbers
end

def is_pentagonal n
  ((Math.sqrt(24 * n + 1) + 1) / 6) % 1 == 0   # Wound up just grabbing this from Wikipedia
end

smallest = 10 ** 9

for i in (0...p_array.length)
  diff = 0
  a = p_array[i]
  for count in (0...i) # Test each pentagonal number smaller than "a"
    b = p_array[count]
    diff = a - b
    sum = a + b
    if is_pentagonal(sum) && is_pentagonal(diff) # This is much faster than checking whether both sum and diff exist in p_array (I tested both)
      smallest = [smallest,diff].min # Could throw in a check to see whether this difference is smaller than the difference between our two largest known pentagonals, but wound up not being necessary for the problem
      array = [a,b]
    end
  end
end

# Ways to do this faster (or at least more simply):
# 1. Write a function where we get each pentagonal number in turn, then 
# compare it to all pentagonal numbers below by generating those numbers on the spot (works faster than mine in non-Ruby languages, at least)

puts smallest # takes about 4 seconds on Inspiron